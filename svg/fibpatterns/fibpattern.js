//==============================================================================
// The SPattern class
//==============================================================================
FibPattern = function (mode, size)
{
    this.size = size;
    this.mode = mode;
    this.num_cells = this.size * this.size;
    this.draw_row = 0;
    this.draw_col = 0;
    this.point_sets = [];
    this.visited = [];
    this.counts = {};
}

FibPattern.SINGLE = 1;
FibPattern.ROW = 2;
FibPattern.COLUMN = 3;
FibPattern.ALL = 4;
FibPattern.DIAGONAL = 5;

// choose colours based on prime factors

FibPattern.colour_map =
{
    0: [    [0,0,0],        [0,0,0]         ],
    1: [    [0.1,0.1,0.1],  [0.9,0.9,0.9]   ],
    2: [    [1,0,0],        [1,1,0]         ],
    3: [    [0,1,1],        [0,0,0.5]       ],
    5: [    [0,0,1],        [1,1,1]         ],
    7: [    [0,1,0],        [1,1,0]         ],
   11: [    [1,1,0],        [0,0,1]         ],
   13: [    [1,0,1],        [1,0,0]         ],
   17: [    [1,1,1],        [1,0,0]         ],
   19: [    [0.5,0.5,0],    [0.1,0,0]       ],
   23: [    [1,0.5,0],      [0.1,0,0]       ],
};

// All primes greater than 19 are mapped to 23.

FibPattern.max_prime = 23;
FibPattern.primes = [2,3,5,7,9,11,13,17,19];

//---------------------------------------------------------------------------------------------
// Creates a pattern based on a single point
//---------------------------------------------------------------------------------------------
FibPattern.prototype.Next = function ()
{
    this.counts = {};

    switch (this.mode)
    {
        case FibPattern.SINGLE:
            ++ this.draw_col;
            if (this.draw_col >= this.size)
            {
                this.draw_col = 0;
                ++ this.draw_row;
                if (this.draw_row >= this.size)
                {
                    this.draw_row = 0;
                }
            }
            break;

        case FibPattern.ROW:
            ++ this.draw_row;
            if (this.draw_row >= this.size)
            {
                this.draw_row = 0;
            }
            break;

        case FibPattern.COLUMN:
            ++ this.draw_col;
            if (this.draw_col >= this.size)
            {
                this.draw_col = 0;
            }
            break;

        case FibPattern.ALL:
        case FibPattern.DIAGONAL:
            break;
    }
    this.Calculate ();
}
//---------------------------------------------------------------------------------------------
FibPattern.prototype.Calculate = function ()
{
    this.point_sets = [];
    this.visited = [];

    switch (this.mode)
    {
        case FibPattern.SINGLE:
            this.CalculateSingle ();
            break;

        case FibPattern.ROW:
            this.CalculateRow ();
            break;

        case FibPattern.COLUMN:
            this.CalculateColumn ();
            break;

        case FibPattern.ALL:
            this.CalculateAll ();
            break;

        case FibPattern.DIAGONAL:
            this.CalculateDiagonal ();
            break;
    }
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by a single point, (x,y)
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculateSingle = function ()
{
    this.CalculatePoint (this.draw_col, this.draw_row);
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by a single column, x = col
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculateColumn = function ()
{
    for (var y = 0 ; y < this.size ; ++y)
    {
        this.CalculatePoint (this.draw_col,y);
    }
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by a single column, y = row
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculateRow = function ()
{
    for (var x = 0 ; x < this.size ; ++x)
    {
        this.CalculatePoint (x,this.draw_row);
    }
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by all the points on the diagonal x = y
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculateDiagonal = function ()
{
    for (var x = 0 ; x < this.size ; ++x)
    {
        this.CalculatePoint (x,x);
    }
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by all the points on the diagonal x = y
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculateAll = function ()
{
    for (var row = 0 ; row < this.size ; ++row)
    {
        for (var col = 0 ; col < this.size ; ++col)
        {
            this.CalculatePoint (col,row);

            if (this.visited.length == this.num_cells - 1)
            {
                break;
            }
        }
    }
}
//---------------------------------------------------------------------------------------------
// Returns a set of co-ordinates generated by a single point, (x,y)
//---------------------------------------------------------------------------------------------
FibPattern.prototype.CalculatePoint = function (x, y)
{
    var pt_key = x * this.size + y;

    if (this.visited.indexOf (pt_key) >= 0)
    {
        return;
    }
    var points = [];

    var xn = x;
    var yn = y;

    while (true)
    {
        var pt_key = xn * this.size + yn;
        this.visited.push (pt_key);

        points.push([xn,yn]);
        xt = yn;
        yn = (xn + yn) % this.size;
        xn = xt;

        if (xn == x && yn == y)
        {
            break;
        }
    }
    this.point_sets.push (points);
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Draw the pattern (in SVG)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FibPattern.prototype.Draw = function (sz)
{
    var size = (sz) ? sz : 500;
    var svg = SVGHelp.Start (size, size, 0, 0, this.size, this.size);

    for (var set in this.point_sets)
    {
        var points = this.point_sets [set];
        var colour = this.GetColour (points[0][0], points[0][1]);

        svg += SVGHelp.Rect (0, this.size - 1, 1, 1, "black", "black");

        for (idx in points)
        {
            var pt = points [idx];
            svg += SVGHelp.Rect (pt[0], this.size - pt[1] - 1, 1, 1, colour, "black");
        }
    }
    return svg;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Statistics about the pattern (HTML table)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FibPattern.prototype.Stats = function ()
{
    var text = "<table><tr><th>Seed</th><th>Colour</th><th>Orbit</th></tr>";

    for (var set in this.point_sets)
    {
        var points = this.point_sets [set];
        var x = points[0][0];
        var y = points[0][1];
        var h1 = hcf (x,y);
        var h2 = (h1 == 0) ? 0 : hcf (h1, this.size);
        var primes = prime_factors (h2);
        var h3 = primes [primes.length-1];

        text += "<tr>";
        text += "<td>(" + x + "," + y + ")</td>";
        text += "<td>" + h3 + "</td>";
        text += "<td>";

        for (idx in points)
        {
            var pt = points [idx];
            if (idx > 0)
            {
                text += ", ";
            }
            text += "(" + pt[0] + "," + pt[1] + ")";
        }
        text += "</td>";
    }
    return text;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Draw the pattern (in SVG)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FibPattern.prototype.GetColour = function (x, y)
{
    var h1 = hcf (x,y);
    var h2 = (h1 == 0) ? 0 : hcf (h1, this.size);
    var primes = prime_factors (h2);
    var h3 = primes [primes.length-1];

    if (this.counts.hasOwnProperty (h3))
    {
        ++ this.counts [h3];
    }
    else
    {
        this.counts [h3] = 0;
    }

    //alert ("HCF [" + [x,y,this.size] + "] = " + h2 + ", primes = " + primes + ", h3 = " + h3 + ", Occurance " + this.counts [h3]);

    var start = [0,0,0];
    var end = [0,0,0];

    var s = FibPattern.colour_map [h3];

    for (var i = 0 ; i < 3 ; ++i)
    {
        start [i] += s [0][i];
        end [i] += s [1][i];
    }

    var n = primes.length;
    var f = FibPattern.GetColourFactor (this.counts [h2]);
    var r = Math.floor (((1 - f) * start [0] + f * end [0]) * 255 / n);
    var g = Math.floor (((1 - f) * start [1] + f * end [1]) * 255 / n);
    var b = Math.floor (((1 - f) * start [2] + f * end [2]) * 255 / n);

    return SVGColours.ToHTMLValue (r, g, b);
}
//-------------------------------------------------------------------------------------------------
FibPattern.GetColourFactor = function (num)
{
    if (num == 0) return 0;

    for (var p = 2; p < 1e20 ; p *= 2)
    {
        if (num < p)
        {
            return (2 * num - p + 1) / p;
        }
    }
    return 1;
}
//-------------------------------------------------------------------------------------------------
// Get the highest common factor
//-------------------------------------------------------------------------------------------------
hcf = function (x, y)
{
    x = Math.round (x);
    y = Math.round (y);

    if (x < 0) x = -x;
    if (y < 0) y = -y;
    if (x == 0) return y;
    if (y == 0) return x;

    return hcf2 (x, y)
}
hcf2 = function (x, y)
{
    if (x == 1 || y == 1) return 1;
    if (x == y) return x;

    return (x > y) ? hcf2 (x-y,x) : hcf2 (x,y-x);
}
prime_factors = function (num)
{
    num = Math.floor (num);

    if (num <= 0) return [0];
    if (num == 1) return [1];

    var ret = [];

    for (var idx in FibPattern.primes)
    {
        while (num % FibPattern.primes [idx] == 0)
        {
            ret.push (FibPattern.primes [idx]);
            num /= FibPattern.primes [idx];
        }
    }
    if (num > 1)
    {
        ret.push (FibPattern.max_prime);
    }
    return ret;
}
