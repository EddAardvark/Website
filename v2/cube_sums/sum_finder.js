
//-------------------------------------------------------------------------------------------------
// Looks for solutions to the equation x^3 + y^3 - z^3 = n
//
// (c) John Whitehouse 2013 - 2019
// www.eddaardvark.co.uk
//
// Uses vlint.js
//-------------------------------------------------------------------------------------------------

CFSolution = function (x,y,z,t,d)
{
    this.x = x;
    this.y = y;
    this.z = z;
    this.d = d;
    this.t = t;
}
CFSolution.prototype.normalise = function ()
{
    if (this.x < this.y)
    {
        var t = this.x;
        this.x = this.y;
        this.y = t;
    }
    if (this.y < this.z)
    {
        var t = this.y;
        this.y = this.z;
        this.z = t;
    }
    if (this.x < this.y)
    {
        var t = this.x;
        this.x = this.y;
        this.y = t;
    }
}
CFSolution.prototype.getValue = function () 
{
    return this.x * this.x * this.x +
            this.y * this.y * this.y +
            this.z * this.z * this.z;
}
CFSolution.prototype.getText = function () 
{
    var sum = this.getValue ();
    
    var op2 = (this.y >= 0) ? "+" + this.y : this.y;
    var op3 = (this.z >= 0) ? "+" + this.z : this.z;
    var op4 = (sum >= 0) ? sum : "&minus;" + -sum;
    return "n+z^3=" + this.t + ", d = " + this.d + ", Solution: " + this.x + "^3" + op2 + "^3" + op3 + "^3" + "=" + op4;
}
CFSolution.prototype.toString = function ()
{
    return this.getText ();
}
CFSolution.prototype.getKey = function () 
{
    var x = this.x;
    var y = this.y;
    var z = this.z;
    
    if (x < y)
    {
        var t = x;
        x = y;
        y = t;
    }
    if (y < z)
    {
        var t = y;
        y = z;
        z = t;
    }
    if (x < y)
    {
        var t = x;
        x = y;
        y = t;
    }
    return "C" + x + "," + y + "," + z;
}
CFSolution.getUnique = function (list)
{
    var temp = {};
    var ret = [];
    
    for (var i in list)
    {
        temp [list[i].getKey()] = list[i];
    }
    var props = Object.getOwnPropertyNames(temp);
    for (var i in props)
    {
        ret.push (temp[props[i]]);
    }
    return ret;
}

//========================================================================================================
CubeSumFinder = function ()
{
    this.list = {};
}

CubeSumFinder.row_size = 81;
CubeSumFinder.cell_size = 10;
CubeSumFinder.map_size = 81 * 81;

// Find solutions
CubeSumFinder.prototype.solve = function (target, limit)
{
    this.result = [];
        
    if (target%9 == 4 || target%9 == 5)
    {
        return ret; // these cases aren't possible
    }
        
    for (var z = 1 ; z <= limit ; ++z)
    {
        var t = target+z*z*z;
        
        if (t < 0) continue;    // For negative targets
        
        var max_d = Math.floor (Math.pow (4*t,1/3));
        var dvals = Primes.GetFactorsLessThan (t, max_d+1);
                    
        for (var j in dvals)
        {
            var d = dvals[j];
            var a = 3;
            var b = -3 * d;
            var c = (d*d-t/d);
            var b2 = b*b-4*a*c;
            
            var sr = Math.round(Math.sqrt(b2));
            
            if (sr * sr == b2)
            {
                var x1 = (-b + sr);
                var x2 = (-b - sr);
                
                if (x1 % 6 == 0)
                {
                    this.result.push(new CFSolution(x1/6, d - x1/6, -z, t, d));
                }

                if (x2 % 6 == 0)
                {
                    this.result.push(new CFSolution(x2/6, d - x2/6, -z, t, d));
                }
            }
        }
    }
}


var temp_count = 0;
        
// Uses the polynomials generated by the single 'z' search but also uses the solutions then 
// the 'x' values aren't integers. Instead they are rounded to the adjacent integers and 
// used to calculate alternative sums. This can be called multiple times to build up the list.
CubeSumFinder.prototype.getNearMisses = function(target, limit, cutoff)
{
    var rows = [];
                
    for (var z = 1 ; z <= limit ; ++z)
    {
        var row = new CFTableRow (target, z);
        var t = target+z*z*z;
        
        if (t < 0) continue;
        
        var max_d = Math.floor (Math.pow (4*t,1/3));
        var dvals = Primes.GetFactorsLessThan (t, max_d+1);
        row.dvals_tested = dvals.length;
                    
        for (var j in dvals)
        {
            var d = dvals[j];
            var a = 3;
            var b = -3 * d;
            var c = (d*d-t/d);
            var op_b = (b > 0) ? ('+' + b) : b;
            var op_c = (c > 0) ? ('+' + c) : c;
            var b2 = b*b-4*a*c;
            var b2t = (b2 > 0) ? b2 : '&minus;' + -b2;
            
            var sqr = Math.sqrt(b2);
            var x = [];
        
            x[0] = Math.floor ((-b + sqr) / 6);
            x[1] = Math.ceil  ((-b + sqr) / 6);
            
            for (var k = 0 ; k < 2 ; ++k)
            {
                var y  = d - x[k];
                var s1 = Math.abs(x[k]*x[k]*x[k] + y*y*y - z*z*z);
                if (s1 < cutoff)
                {
                    var sol = new CFSolution(x[k], y, z, t, d);
                    var key = sol.getKey ();
                    
                    if (! this.list.hasOwnProperty (key))
                    {
                        sol.normalise();
                        this.list [key] = sol;
                        
                        row.found.push (s1);
                    }
                }
            }
        }
        rows.push (row);
    }
    return rows;
}

CubeSumFinder.prototype.normalise = function ()
{
    for (var i in this.result)
    {
        this.result[i].normalise();
    }
}

CubeSumFinder.prototype.getUnique = function ()
{
    return CFSolution.getUnique (this.result);
}

// Use the list to populate the map, returns the count.
CubeSumFinder.prototype.makeMap = function ()
{
    this.map = new Array (CubeSumFinder.map_size);

    for (var i = 0 ; i < CubeSumFinder.map_size ; ++i)
    {
        this.map[i] = 0;
    }
    
    var count = 0;
    
    var keys = Object.getOwnPropertyNames(this.list);
    
    for (var i in keys)
    {
        var sol = this.list[keys[i]];
        var v = sol.getValue ();
        
        if (v < CubeSumFinder.map_size)
        {
            if (this.map [v] == 0) count ++;
            this.map [v] ++;
            console.log (Misc.Format ("Pos = {0}, map = {1}, count = {2}", v, this.map[v], count));
        }
    }
    return count;
}

CubeSumFinder.prototype.drawMap = function (image)
{    
    var w = CubeSumFinder.row_size * CubeSumFinder.cell_size;
    var chelp = new CanvasHelp (w, w);
    
    // background

    chelp.SetBackground ("aliceblue");
    chelp.DrawFilledRect (0, 0, w, w);

    for (var i = 0 ; i < 9 ; ++i)
    {
        var x1 = (4 + 9 * i) * CubeSumFinder.cell_size;
        
        chelp.SetForeground ("pink");
        chelp.SetBackground ("pink");
        chelp.DrawFilledRect (x1, 0, 2 * CubeSumFinder.cell_size, CubeSumFinder.row_size * CubeSumFinder.cell_size);
    }

    for (var i in this.map)
    {
    
        if (this.map [i] > 0)
        {
            var c = (this.map [i] > 1) ? "red" : "midnightblue";
            var x = (i % CubeSumFinder.row_size) * CubeSumFinder.cell_size;
            var y = Math.floor(i / CubeSumFinder.row_size) * CubeSumFinder.cell_size;
            
            chelp.SetForeground (c);
            chelp.SetBackground (c);
            chelp.DrawFilledRect (x, y, CubeSumFinder.cell_size, CubeSumFinder.cell_size);
        }
    }
    
    chelp.SetForeground ("LightSteelBlue");
    
    for (var i = 1 ; i < 9 ; ++i)
    {
        var xy = i * 9 * CubeSumFinder.cell_size;
        
        chelp.DrawLine ([0,xy], [w,xy]);
        chelp.DrawLine ([xy,0], [xy,w]);
    }
    
    image.src = chelp.canvas.toDataURL('image/png');
}

CFTableRow = function (k, z)
{
    this.target = k;
    this.z = z;
    this.found = [];
    this.dvals_tested = 0;
}

    
    
        
        


    


